#pragma once

#include "Filters/Filter.hpp"

namespace Vision {
namespace Filters {

/// Uses an idea based on the approach proposed by Berlin United (spl team) at RoHOW 2017 to
/// identify the best 'n' regions of interest
///
/// Input:
/// - Y     : An integral image of (rows + 1, cols + 1) (CV32S)
/// - Green : An integral image of (rows + 1, cols + 1) (CV32S)
/// - Radius: An image providing the expected radius for each pixel (CV_8F)
/// Output:
/// - An image of (rows, cols) where pixels are colored in red or blue depending on their value
class BallByII : public Filter {
public:
  BallByII() : Filter("BallByII") {}

  virtual std::string getClassName() const override;
  virtual int expectedDependencies() const override;

protected:
  virtual void process() override;

  virtual void setParameters() override;

  cv::Mat getHeatMap(const cv::Mat & scores, double minScore, double maxScore) const;

private:
  /// Return the half width corresponding to a ball of the given radius
  double getBoundaryHalfWidth(float radius);
  /// Return the patch associated to the inner part of the ball at the given point
  cv::Rect_<float> getInnerPatch(int x, int y, float radius);
  /// Return the patch associated to the inner upper part of the ball at the given point
  cv::Rect_<float> getInnerAbovePatch(int x, int y, float radius);
  /// Return the patch associated to the inner bottom part of the ball at the given point
  cv::Rect_<float> getInnerBelowPatch(int x, int y, float radius);
  /// Return the patch associated to the boundary part of the ball at the given point
  cv::Rect_<float> getBoundaryPatch(int x, int y, float radius);
  /// Return the patch associated to the upper boundary part of the ball at the given point
  cv::Rect_<float> getBoundaryAbovePatch(int x, int y, float radius);

  /// Return the score of the patch given the provided integralImage
  double getPatchScore(const cv::Rect & patch,
                       const cv::Mat & integralImage);

  double getCandidateScore(int center_x, int center_y, double radius,
                           const cv::Mat & y_img, const cv::Mat & green_img);

  /// img should be CV_32SC1
  /// draw pixels in [start_x,end_x[ * [start_y,end_y[
  void fillScore(cv::Mat & img, int score,
                 int start_x, int end_x,
                 int start_y, int end_y);

  /// Number of rows in the result image
  int rows;

  /// Number of columns in the result image;
  int cols;

  /// Usual size ratio between inner side and boundary side
  ParamFloat boundaryFactor;

  /// The maximal thickness of the border area
  ParamFloat maxBoundaryThickness;

  /// Minimal radius of the ball in pixels for the size of image used
  ParamFloat minRadius;

  /// Minimal score for considering that region of interest is acceptable
  /// Reminder: Scores are in [-255,510] (2 * B - I)
  ParamFloat minScore;

  /// the weight of the 'Y' component on a patch score
  ParamFloat yWeight;

  /// The weight of green inside a patch score
  ParamFloat greenWeight;

  /// Maximal number of ROI generated by the filter
  ParamInt maxRois;

  /// Since using a high resolution Integral Image helps to detect balls which
  /// are far away, a decimationRate is used to compute the score function only
  /// at an interval given by decimationRate
  ParamInt decimationRate;

  /// 0: No heatMap produced
  ParamInt tagLevel;

  /// If enabled, a local search is used nearby every selected candidate
  ParamInt useLocalSearch;
};
}
}


